# Order processing service

## Проблема

Нужно разработать систему, которая будет получать назначенные на исполнителей заказы, агрегировать внутри себя информацию о таких заказах и передавать эту информацию исполнителям.

## Общая схема

Предлагается реализовать систему в виде одного сервиса с базой данных, который будет взаимодействовать с двумя другими системами: системой по назначению заказов на исполнителей и с клиентом пользователя, через который исполнитель смотрит назначенные на него заказы.

Информация о назначении/отмене заказа будет реализована по Push-модели — система по назначению дергает соответствующие ручки сервиса.

Получение информации об очередном назначенном заказе на исполнителя будет реализовано по Pull-модели — клиенты исполинетелей 1 раз в минуту будут дергать ручку получения информации о назначенном на них заказе.

TDB: Как наполнять заказы инфой (синхронно, асинхронно)

### Внешние источники данных

Перед передачей заказа, он будет обогащаться информацией из различных источников. На данный момент будет реализована поддержка следущих источников данных:

- Данные о заказе (является критичными)
- Данные об исполнителе (являются критичными)
- Данные о зоне заказа
- Данные о платных дорогах

#### Логика получения данных

Получение данных будет реализовано с помощью сетевых походов в сервисы, хранящие соответствующую информацию. При отсутствии критичных данных (о заказе, об исполниетеле) или недоступности соответствуюзих сервисов, заказ не будет передан исполнителю.

Для некритичных данных (или их неактуальности) будет реализована следующая логика:

Для каждого типа данных будет реализован TTL-кэш. При необходимости получения информации о зоне доставки/платной дороге, сначала будет совершаться сетевой поход. При успешном запросе данные и TTL в кэше будут обновляться.

При неуспешном запросе (если сервис вернул ошибку или стал недоступен), данные будут браться из кэша при условии, что они не протухли (TTL еще не прошел).

Если же кэш протух, то будут браться дефолтные значения, задаваемые в конфиге.

#### Формат данных

- Данные о заказе:

    ```
    OrderInfo:
        properties:
            id:
                type: string
                description: Идентификатор заказа
            zone_id:
                type: string
                description: Идентификатор зоны доставки, в которой находится заказ
            customer_id:
                type: string
                description: Идентификатор заказчика
            base_cost:
                type: float
                description: Базовая стоимость заказа без учета доставки
    ```

- Данные об исполнителе:

    ```
    ExecutorInfo:
        properties:
            id:
                type: string
                description: Идентификатор исполнителя
            tags:
                type: array
                items:
                    type: string
                desctiption: Набор тегов исполинеля
            rating:
                type: float
                description: Рейтинг исполнителя
    ```

- Данные о зоне доставки заказа

    ```
    ZoneInfo:
        properties:
            id:
                type: string
                description: Идентификатор зоны
            name:
                type: string
                description: Название зоны
            coef:
                type: number
                format: float
                description: Коэффициент стоимости доставки в зоне
    ```

- Данные о платных дорогах

    ```
    TollRoadInfo:
        properties:
            id:
                type: string
                description: Идентификатор платной дороги
            zone_id:
                type: string
                description: Идентификатор зоны, содержащей данную дорогу
            cost:
                type: number
                format: float
                description: Стоимость проезда по данной дороге
    ```

### Реализуемые ручки сервиса

Сервис будет поддерживать 3 ручки (формальное описание ручек с контрактом и логикой будет описано далее):

- `POST /order/assign`:

    Назначение заказа на исполнителя. Дергается системой по назначению заказов.

- `POST /order/cancel`:

    Отмена заказ по его id. Дергается системой по назначению заказов.

- `GET /order/aquire`

    Получить информацию об очередном назначенном заказе. Дергается клиентом пользователя.

#### Контракт ручек

Весь контракт описан в файле [api.yaml](api.yaml)

#### Про назначение

Конкретный заказ идентифицируется по 2-м айдишникам — `order_nr` и `executor_id`.

При попытке назначить заказ с одинаковым набором (`order_nr`, `executor_id`), ручка вернет 409 (при условии, если существующий заказ не отменен).

В остальных случаях ручка вернет 200, а сервис запишет заказ в БД и запустит логику наполнения заказа информацией из внешних источников.

#### Про отмену заказа

Отмена заказа возможно только в течение X минут после его назначения на исполнителя. Данный параметр будет задаваться в конфиге. Если система попытается отменить заказ после истечения X минут, ручка вернет 403 с ошибкой.

Если система попытается отменить неназначенный заказ (которого нет в базе сервиса), ручка вернет 404.

В остальных случаях ручка вернет 200, а назначенный заказ будет помечен отмененным (отдельное поле в таблице).

#### Про получение заказа исполнителем

В ручке получения очередного назначенного заказа исполнитель передает свой `executor_id`.

Если в базе не было найдено неназначенных заказов, ручка вернет 204.

Если есть хотя бы 1 неназначенный заказ, то выберется самый старый из них, а также пометится признаком взятия в БД. Сама информация о заказе вернется в ручке.

Важно отметить, что будет поддерживаться критерий наполненности заказа данынми. Если заказ не наполнен всеми необходимыми данными, он не будет возвращен пользователю. TODO: подробнее описать этот механизм и учеть признаки в БД.

## Стуктура БД

В нашем варианте мы знаем, что новых заказов 10RPS - это не IO bound ограничение оно будет тривиально удовлетворяться. Куда более трудным представляется 1kk исполнителей, каждый из которых раз в минуту делает запрос -> примерно 16к RPS запросов о статусе заказа. Также мы знаем, что каждый из 10 новых заказов в секунду весит 100 кб, то есть имеем 1мб/сек.

Помним, что хранить заказы нам нужно в течение двух лет -> получаем примерно 60Тб данных, которые нужно помнить в базке - нетривиальная задача.

Будем юзать postgres и я опишу схему шардов, которую нужно было бы поддержать.

Пусть имеем 3 геораспределенных ДЦ (из соображений, что наши пользователи могут быть из разных частей мира, уменьшаем пинг, устойчивость и тд) вообще их может быть больше, но для 3 уже достаточная отказоусточивость на случай пожара/наводнения/нападения инопланетян на конкретный ДЦ.

В каждом шарде поддерживаем 3 пода (по числу ДЦ) по одному в каждом ДЦ. Исходя из нашей бд внутри тройки master-slave архитектура. Всего 20 шардов. Поддерживаем инвариант того, что трафик на запись гоним в мастер(1/20 mb/sec точно переварит с синхронной репликацей). Трафика на чтение у нас примерно 16к RPS, оценим, что читаем весь заказ то есть 1600 мб/сек или 80 мб/сек на шард.

Трафик на чтение равномерно балансером распределяем на slave - синхронная репликация нам это позволяет. Получаем 40мб/сек на под - жить можно.

Про принцип шардирования заказов скажу пару слов: мы договорились, что id заказа это uuid-4 --- это достаточно равномерный генератор, можем выбирать шард простым остатком по модулю 20(числа шардов) от uuid-4(суммы от его символов например). Можно запариться и брать хэш от uuid4 и от него остаток от деления, но лонг стори шорт заказы будут распределны достаточно равномерно между шардами.

## Нагрузка

TBD